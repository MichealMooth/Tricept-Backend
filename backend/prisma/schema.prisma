// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}


model UserProfile {
  id               String   @id @default(uuid())
  userId           String   @unique
  firstName        String
  lastName         String
  roleTitle        String
  mainFocus        String
  projectReferences String  @default("{}") // JSON string: { current, past }
  experience       String
  certifications   String
  tools            String   @default("[]") // JSON string: string[]
  methods          String   @default("[]") // JSON string: string[]
  softSkills       String   @default("[]") // JSON string: string[]
  education        String
  profileImageUrl  String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  user Employee @relation(fields: [userId], references: [id])
}


model StrategicGoal {
  id           String   @id @default(uuid())
  key          String   @unique // e.g., SG-2025-01
  title        String
  description  String?
  displayOrder Int      @default(0)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Scope classification fields (Task Group 2)
  // DataScope values: GLOBAL, TEAM, USER (validated at application layer)
  scope        String   @default("GLOBAL") // DataScope: GLOBAL, TEAM, USER
  teamGroupId  String?  // nullable: only set when scope=TEAM

  // Relations
  ratings   StrategicGoalRating[]
  teamGroup TeamGroup?            @relation(fields: [teamGroupId], references: [id])

  @@index([scope])
  @@index([teamGroupId])
}

model StrategicGoalRating {
  id        String   @id @default(uuid())
  goalId    String
  userId    String
  year      Int
  month     Int // 1-12
  rating    Int      // 1..5 (1=rot, 2=gelb-rot, 3=gelb, 4=gelb-gruen, 5=gruen)
  comment   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  goal StrategicGoal @relation(fields: [goalId], references: [id])
  user Employee      @relation(fields: [userId], references: [id])

  @@unique([goalId, userId, year, month])
  @@index([year, month])
}

model UserCapacity {
  id            String   @id @default(uuid())
  userId        String
  year          Int
  month         Int // 1-12
  allocations   String  @default("[]") // JSON string: [{ project_name?: string, percent: number }]
  totalPercent  Int     // 0-100
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user Employee @relation(fields: [userId], references: [id])

  @@unique([userId, year, month])
  @@index([year])
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Employee {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  firstName    String
  lastName     String
  role         String?
  department   String   @default("Consulting")
  isActive     Boolean  @default(true)
  isAdmin      Boolean  @default(false)
  hireDate     DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  selfAssessments   SkillAssessment[] @relation("EmployeeSelfAssessments")
  givenAssessments  SkillAssessment[] @relation("EmployeeGivenAssessments")
  capacities        UserCapacity[]
  strategicRatings  StrategicGoalRating[]
  profile           UserProfile?
  referenceProjects ReferenceProjectEmployee[]
  teamMemberships   TeamMembership[]
}

model Skill {
  id           String   @id @default(uuid())
  name         String
  categoryId   String
  description  String?
  displayOrder Int      @default(0)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())

  // Relations
  category    SkillCategory   @relation(fields: [categoryId], references: [id])
  assessments SkillAssessment[]

  @@index([categoryId])
}

model SkillCategory {
  id            String   @id @default(uuid())
  name          String   @unique
  parentId      String?
  description   String?
  displayOrder  Int      @default(0)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())

  // Relations
  parent   SkillCategory? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children SkillCategory[] @relation("CategoryHierarchy")
  skills   Skill[]

  @@index([parentId])
}

model SkillAssessment {
  id             String          @id @default(uuid())
  employeeId     String
  skillId        String
  assessmentType String
  assessorId     String?
  rating         Int
  comment        String?
  validFrom      DateTime        @default(now())
  validTo        DateTime?
  createdAt      DateTime        @default(now())

  // Relations
  employee Employee @relation("EmployeeSelfAssessments", fields: [employeeId], references: [id])
  assessor Employee? @relation("EmployeeGivenAssessments", fields: [assessorId], references: [id])
  skill    Skill     @relation(fields: [skillId], references: [id])

  @@index([employeeId, validTo])
  @@index([skillId, validTo])
}

// ============================================
// Reference Projects Models (Task Group 1)
// ============================================

// Role lookup table for reference projects
// Extensible via database (later Admin-UI)
model Role {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  referenceProjects ReferenceProject[]
}

// Topic lookup table for reference projects
// Extensible via database (later Admin-UI)
model Topic {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  referenceProjects ReferenceProjectTopic[]
}

// Main ReferenceProject model
// Migrated from file-based store (backend/var/reference-projects.json)
model ReferenceProject {
  id                        String   @id @default(uuid())
  project_name              String
  customer                  String
  project_description       String
  activity_description      String
  duration_from             String   // Format: YYYY-MM or similar
  duration_to               String   // Format: YYYY-MM or similar
  contact_person            String
  approved                  Boolean  @default(false)

  // New optional fields for enhanced schema
  short_teaser              String?  // 100-150 chars, validated at service layer
  short_project_description String?  // Longer text, no length limit

  // Fallback field for unmatched employee references during migration
  person_legacy             String?

  // Foreign key to Role lookup table
  roleId                    String

  // Timestamps
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  // Relations
  role      Role                       @relation(fields: [roleId], references: [id])
  topics    ReferenceProjectTopic[]
  employees ReferenceProjectEmployee[]

  @@index([roleId])
  @@index([approved])
}

// Junction table for Many-to-Many: ReferenceProject <-> Topic
// Business rule: max 6 topics per project (validated at service layer)
model ReferenceProjectTopic {
  referenceProjectId String
  topicId            String

  // Relations
  referenceProject ReferenceProject @relation(fields: [referenceProjectId], references: [id], onDelete: Cascade)
  topic            Topic            @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@id([referenceProjectId, topicId])
  @@index([topicId])
}

// Junction table for Many-to-Many: ReferenceProject <-> Employee
// Minimal structure: FK fields only (no role, involvement %, dates)
// Future extension possible but out of scope for this migration
model ReferenceProjectEmployee {
  referenceProjectId String
  employeeId         String

  // Relations
  referenceProject ReferenceProject @relation(fields: [referenceProjectId], references: [id], onDelete: Cascade)
  employee         Employee         @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@id([referenceProjectId, employeeId])
  @@index([employeeId])
}

// ============================================
// TeamGroup & Authorization Models
// ============================================

// TeamRole values (validated at application layer via Zod):
// - OWNER: full rights including role/membership management within the TeamGroup
// - ADMIN: manage team content, cannot manage memberships
// - EDITOR: create/update team-scoped content
// - VIEWER: read-only access to team content
// - USER: basic rights on own data only
// Note: SQLite does not support native enums, so we use String with application-level validation

// DataScope values (validated at application layer via Zod):
// - GLOBAL: readable by all authenticated users, writable by Global Admin only
// - TEAM: visible to TeamGroup members only
// - USER: owner-only access
// Note: SQLite does not support native enums, so we use String with application-level validation

// QuestionnaireStatus values (validated at application layer via Zod):
// - DRAFT: questionnaire is being created/edited
// - ACTIVE: questionnaire is live and can be filled out
// - ARCHIVED: questionnaire is no longer active but preserved for history
// Note: SQLite does not support native enums, so we use String with application-level validation

// TeamGroup model for grouping users (department/team/project group)
// A user can belong to multiple TeamGroups with different roles in each
model TeamGroup {
  id          String   @id @default(uuid())
  name        String
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // Audit: userId who created this record
  updatedBy   String?  // Audit: userId who last updated this record

  // Relations
  memberships    TeamMembership[]
  strategicGoals StrategicGoal[]
  questionnaires Questionnaire[]
  moduleConfigs  TeamModuleConfig[]

  @@index([isActive])
}

// Junction table for Many-to-Many: Employee <-> TeamGroup with role
// Roles are context-dependent: permissions apply only within the associated TeamGroup
model TeamMembership {
  id          String   @id @default(uuid())
  employeeId  String
  teamGroupId String
  role        String   @default("USER") // TeamRole: OWNER, ADMIN, EDITOR, VIEWER, USER
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // Audit: userId who created this record
  updatedBy   String?  // Audit: userId who last updated this record

  // Relations
  employee  Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  teamGroup TeamGroup @relation(fields: [teamGroupId], references: [id], onDelete: Cascade)

  // Composite unique constraint: one membership per employee per team
  @@unique([employeeId, teamGroupId])
  @@index([employeeId])
  @@index([teamGroupId])
}

// ============================================
// Questionnaire Models (Task Group 2)
// ============================================

// Questionnaire model for structured data collection
// Supports versioning via status field and version number
// Scope follows same GLOBAL/TEAM pattern as StrategicGoals
model Questionnaire {
  id          String   @id @default(uuid())
  title       String
  description String?
  version     Int      @default(1)
  status      String   @default("DRAFT") // QuestionnaireStatus: DRAFT, ACTIVE, ARCHIVED
  scope       String   @default("GLOBAL") // DataScope: GLOBAL, TEAM, USER
  teamGroupId String?  // nullable: only set when scope=TEAM
  createdAt   DateTime @default(now())
  createdBy   String?  // Audit: userId who created this record
  updatedAt   DateTime @updatedAt
  updatedBy   String?  // Audit: userId who last updated this record

  // Relations
  teamGroup TeamGroup? @relation(fields: [teamGroupId], references: [id])
  questions Question[]

  @@index([status])
  @@index([scope])
  @@index([teamGroupId])
}

// Question model for individual questions within a questionnaire
// Uses JSON string pattern for options (like allocations in UserCapacity)
model Question {
  id              String   @id @default(uuid())
  questionnaireId String
  questionText    String
  questionType    String   // e.g., TEXT, RATING, CHOICE, MULTI_CHOICE
  displayOrder    Int      @default(0)
  isRequired      Boolean  @default(false)
  options         String   @default("[]") // JSON string: for CHOICE/MULTI_CHOICE types
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  questionnaire Questionnaire @relation(fields: [questionnaireId], references: [id], onDelete: Cascade)

  @@index([questionnaireId])
  @@index([displayOrder])
}

// ============================================
// Module Configuration Models
// ============================================

// TeamModuleConfig: Team-specific module configuration overrides
// Stores which modules are enabled/disabled for each team and their scope override
// Module definitions are code-based (modules.registry.ts); this only stores overrides
model TeamModuleConfig {
  id          String   @id @default(uuid())
  teamGroupId String
  moduleId    String   // References code-based module registry (e.g., 'strategic-goals')
  isEnabled   Boolean  @default(true)
  scope       String?  // Override scope (null = use module default); values: GLOBAL, TEAM, USER
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // Audit: userId who created this record
  updatedBy   String?  // Audit: userId who last updated this record

  // Relations
  teamGroup TeamGroup @relation(fields: [teamGroupId], references: [id], onDelete: Cascade)

  // Unique constraint: one config per team per module
  @@unique([teamGroupId, moduleId])
  @@index([teamGroupId])
  @@index([moduleId])
}

// ModuleConfigAudit: Audit trail for module configuration changes
// Separate table for compliance queries and historical analysis
// No foreign keys to preserve audit history even if team/module deleted
model ModuleConfigAudit {
  id          String   @id @default(uuid())
  teamGroupId String   // Team ID at time of change (not FK)
  moduleId    String   // Module ID at time of change
  action      String   // CREATE, UPDATE, DELETE
  oldValues   String?  // JSON string of previous state
  newValues   String?  // JSON string of new state
  performedBy String   // User ID who made the change
  performedAt DateTime @default(now())

  @@index([teamGroupId])
  @@index([moduleId])
  @@index([performedAt])
}
